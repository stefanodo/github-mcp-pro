name: Auto PR Tools

on:
  push:
    branches-ignore:
      - main
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]

permissions:
    contents: write
    statuses: write
    issues: write
    pull-requests: write

jobs:
  run-tools:
    if: github.event_name == 'push' || github.event.pull_request.draft == false
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Run automated MCP tools
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          EVENT_NAME: ${{ github.event_name }}
          REPO: ${{ github.repository }}
          PR_ID: ${{ github.event.pull_request.number }}
          REF_NAME: ${{ github.ref_name }}
          BEFORE_SHA: ${{ github.event.before }}
          HEAD_SHA: ${{ github.sha }}
        run: |
          python - <<'PY'
          import os
          import sys
          import re
          from collections import Counter
          from github import Github, Auth
          from main import review_pr, assess_pr_risk

          event_name = os.environ["EVENT_NAME"]
          repo = os.environ["REPO"]
          token = os.environ["GITHUB_TOKEN"]
          ref_name = os.environ.get("REF_NAME", "")
          before_sha = os.environ.get("BEFORE_SHA", "")
          head_sha = os.environ.get("HEAD_SHA", "")

          gh = Github(auth=Auth.Token(token))
          gh_repo = gh.get_repo(repo)

          ghp_prefix = "gh" + "p_"
          pat_prefix = "github_" + "pat_"
          token_pattern = re.compile(
              rf"{ghp_prefix}[A-Za-z0-9]{{20,}}|{pat_prefix}[A-Za-z0-9_]{{20,}}"
          )

          def is_placeholder_token(path: str, line: str, token_value: str) -> bool:
              lowered_line = line.lower()
              lowered_path = path.lower()

              if (
                  "exampletoken" in token_value.lower()
                  or "your_token_here" in lowered_line
                  or "replace_with_real_token" in lowered_line
                  or "<real-github-token>" in lowered_line
              ):
                  return True

              if lowered_path in {"readme.md", ".env.example", "scripts/security_selfcheck.py"}:
                  return True

              return False

          def add_findings_from_patch(path: str, patch: str, findings: list[str]) -> None:
              if not patch:
                  return

              lowered = patch.lower()
              if "console.log" in lowered:
                  findings.append(f"MINOR: {path} contains console.log")

              for raw in patch.splitlines():
                  if not raw.startswith("+") or raw.startswith("+++"):
                      continue

                  line = raw[1:]
                  stripped = line.strip()

                  if "findings.append(" in stripped and (
                      "eval() added" in stripped
                      or "potential hardcoded GitHub token" in stripped
                  ):
                      continue

                  if re.search(r"(?<!['\"])\beval\s*\(", line):
                      findings.append(f"CRITICAL: {path} eval() added")
                  if re.search(r"(?<!['\"])\bdebugger\b", line):
                      findings.append(f"MAJOR: {path} debugger statement added")
                  if re.search(r"^\s*except\s*:\s*$", line):
                      findings.append(f"MAJOR: {path} bare except detected")
                  token_match = token_pattern.search(line)
                  if token_match:
                      token_value = token_match.group(0)
                      if not is_placeholder_token(path, line, token_value):
                          findings.append(f"CRITICAL: {path} potential hardcoded GitHub token")
                  if "password" in stripped.lower() and "=" in stripped and "\"" in stripped:
                      findings.append(f"MAJOR: {path} possible hardcoded password")
                  if "todo" in stripped.lower() or "fixme" in stripped.lower():
                      findings.append(f"INFO: {path} TODO/FIXME added")

          def summarize_findings(findings: list[str]) -> Counter:
              counts = Counter()
              for finding in findings:
                  if finding.startswith("CRITICAL"):
                      counts["critical"] += 1
                  elif finding.startswith("MAJOR"):
                      counts["major"] += 1
                  elif finding.startswith("MINOR"):
                      counts["minor"] += 1
                  else:
                      counts["info"] += 1
              return counts

          def post_quality_gate(commit_sha: str, counts: Counter, scope: str) -> bool:
              critical_count = counts.get("critical", 0)
              commit = gh_repo.get_commit(commit_sha)

              if critical_count > 0:
                  commit.create_status(
                      state="failure",
                      description=f"MCP quality gate failed: {critical_count} critical finding(s)",
                      context="github-mcp-pro/quality-gate",
                  )
                  print(f"Quality gate failed for {scope}: {critical_count} critical finding(s).")
                  return False

              commit.create_status(
                  state="success",
                  description="MCP quality gate passed",
                  context="github-mcp-pro/quality-gate",
              )
              print(f"Quality gate passed for {scope}.")
              return True

          def run_branch_commit_feedback() -> None:
              commit = gh_repo.get_commit(head_sha)

              if not before_sha or before_sha == "0000000000000000000000000000000000000000":
                  commit.create_status(
                      state="success",
                      description="MCP branch feedback skipped (no compare base)",
                      context="github-mcp-pro/branch-feedback",
                  )
                  print("No valid before SHA for compare. Skipping branch feedback.")
                  return

              comparison = gh_repo.compare(before_sha, head_sha)
              files = list(comparison.files)
              findings: list[str] = []

              for changed_file in files:
                  add_findings_from_patch(changed_file.filename, changed_file.patch or "", findings)

              counts = summarize_findings(findings)

              header = "<!-- mcp-branch-feedback -->\n**ðŸ¤– Automated Branch Commit Feedback**"
              summary = (
                  f"- Branch: `{ref_name}`\n"
                  f"- Commit: `{head_sha[:12]}`\n"
                  f"- Files changed: {len(files)}\n"
                  f"- Findings: critical {counts['critical']}, major {counts['major']}, minor {counts['minor']}, info {counts['info']}"
              )

              if findings:
                  top = "\n".join(f"- {item}" for item in findings[:12])
              else:
                  top = "- No common risk/lint patterns detected in this commit range."

              body = f"{header}\n\n{summary}\n\n**Top findings**\n{top}"

              commit.create_comment(body)
              commit.create_status(
                  state="success",
                  description="MCP branch feedback posted",
                  context="github-mcp-pro/branch-feedback",
              )

              if not post_quality_gate(head_sha, counts, "branch push"):
                  sys.exit(1)

          if event_name == "pull_request":
              pr_id = int(os.environ["PR_ID"])
          else:
              owner = repo.split("/")[0]
              head_selector = f"{owner}:{ref_name}"
              pulls = list(gh_repo.get_pulls(state="open", head=head_selector))
              if not pulls:
                  print(f"No open PR found for branch '{ref_name}'. Running branch commit feedback.")
                  run_branch_commit_feedback()
                  sys.exit(0)
              pr_id = pulls[0].number

          review_result = review_pr.fn(repo=repo, pr_id=pr_id)
          risk_result = assess_pr_risk.fn(repo=repo, pr_id=pr_id)

          print(review_result)
          print(risk_result)

          pr = gh_repo.get_pull(pr_id)
          marker = "<!-- mcp-risk-assessment -->"
          body = f"{marker}\n**ðŸ¤– Automated PR Risk Assessment**\n\n```text\n{risk_result}\n```"

          existing = None
          for comment in pr.get_issue_comments():
              if comment.body and marker in comment.body:
                  existing = comment
                  break

          if existing:
              existing.edit(body)
          else:
              pr.create_issue_comment(body)

          pr_findings: list[str] = []
          for changed_file in pr.get_files():
              add_findings_from_patch(changed_file.filename, changed_file.patch or "", pr_findings)

          pr_counts = summarize_findings(pr_findings)
          if not post_quality_gate(pr.head.sha, pr_counts, f"PR #{pr_id}"):
              sys.exit(1)
          PY
